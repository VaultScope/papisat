using System;
using System.Collections.ObjectModel;
using System.Linq;
using System.Reactive;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using ReactiveUI;
using VaultScope.Core.Interfaces;
using VaultScope.Core.Models;

namespace VaultScope.UI.ViewModels;

public class VulnerabilityDetailsViewModel : ViewModelBase
{
    private readonly IScanRepository _scanRepository;
    private readonly ILogger<VulnerabilityDetailsViewModel> _logger;
    
    private Vulnerability? _selectedVulnerability;
    private string _searchText = string.Empty;
    private VulnerabilitySeverity? _selectedSeverityFilter;
    private string _selectedTypeFilter = "All";
    private bool _isLoading;
    private int _totalVulnerabilities;
    private int _criticalCount;
    private int _highCount;
    private int _mediumCount;
    private int _lowCount;

    public VulnerabilityDetailsViewModel(IScanRepository scanRepository, ILogger<VulnerabilityDetailsViewModel> logger)
    {
        _scanRepository = scanRepository;
        _logger = logger;
        
        Vulnerabilities = new ObservableCollection<Vulnerability>();
        FilteredVulnerabilities = new ObservableCollection<Vulnerability>();
        VulnerabilityTypes = new ObservableCollection<string>();
        
        LoadVulnerabilitiesCommand = ReactiveCommand.CreateFromTask(LoadVulnerabilities);
        RefreshCommand = ReactiveCommand.CreateFromTask(RefreshVulnerabilities);
        ViewDetailsCommand = ReactiveCommand.Create<Vulnerability>(ViewDetails);
        ExportVulnerabilityCommand = ReactiveCommand.CreateFromTask<Vulnerability>(ExportVulnerability);
        
        // Load vulnerabilities on initialization
        LoadVulnerabilitiesCommand.Execute().Subscribe();
        
        // Set up filtering
        this.WhenAnyValue(x => x.SearchText, x => x.SelectedSeverityFilter, x => x.SelectedTypeFilter)
            .Subscribe(_ => FilterVulnerabilities());
    }

    public ObservableCollection<Vulnerability> Vulnerabilities { get; }
    public ObservableCollection<Vulnerability> FilteredVulnerabilities { get; }
    public ObservableCollection<string> VulnerabilityTypes { get; }

    public Vulnerability? SelectedVulnerability
    {
        get => _selectedVulnerability;
        set => this.RaiseAndSetIfChanged(ref _selectedVulnerability, value);
    }

    public string SearchText
    {
        get => _searchText;
        set => this.RaiseAndSetIfChanged(ref _searchText, value);
    }

    public VulnerabilitySeverity? SelectedSeverityFilter
    {
        get => _selectedSeverityFilter;
        set => this.RaiseAndSetIfChanged(ref _selectedSeverityFilter, value);
    }

    public string SelectedTypeFilter
    {
        get => _selectedTypeFilter;
        set => this.RaiseAndSetIfChanged(ref _selectedTypeFilter, value);
    }

    public bool IsLoading
    {
        get => _isLoading;
        set => this.RaiseAndSetIfChanged(ref _isLoading, value);
    }

    public int TotalVulnerabilities
    {
        get => _totalVulnerabilities;
        set => this.RaiseAndSetIfChanged(ref _totalVulnerabilities, value);
    }

    public int CriticalCount
    {
        get => _criticalCount;
        set => this.RaiseAndSetIfChanged(ref _criticalCount, value);
    }

    public int HighCount
    {
        get => _highCount;
        set => this.RaiseAndSetIfChanged(ref _highCount, value);
    }

    public int MediumCount
    {
        get => _mediumCount;
        set => this.RaiseAndSetIfChanged(ref _mediumCount, value);
    }

    public int LowCount
    {
        get => _lowCount;
        set => this.RaiseAndSetIfChanged(ref _lowCount, value);
    }

    public ReactiveCommand<Unit, Unit> LoadVulnerabilitiesCommand { get; }
    public ReactiveCommand<Unit, Unit> RefreshCommand { get; }
    public ReactiveCommand<Vulnerability, Unit> ViewDetailsCommand { get; }
    public ReactiveCommand<Vulnerability, Unit> ExportVulnerabilityCommand { get; }

    private async Task LoadVulnerabilities()
    {
        try
        {
            IsLoading = true;
            _logger.LogInformation("Loading vulnerabilities");

            var scanResults = await _scanRepository.GetAllScanResultsAsync();
            var allVulnerabilities = scanResults
                .SelectMany(scan => scan.Vulnerabilities)
                .OrderByDescending(v => v.Severity)
                .ThenByDescending(v => v.DiscoveredAt)
                .ToList();

            Vulnerabilities.Clear();
            foreach (var vulnerability in allVulnerabilities)
            {
                Vulnerabilities.Add(vulnerability);
            }

            // Update vulnerability types for filtering
            VulnerabilityTypes.Clear();
            VulnerabilityTypes.Add("All");
            var types = allVulnerabilities.Select(v => v.Type).Distinct().OrderBy(t => t);
            foreach (var type in types)
            {
                VulnerabilityTypes.Add(type);
            }

            // Calculate summary statistics
            TotalVulnerabilities = allVulnerabilities.Count();
            CriticalCount = allVulnerabilities.Count(v => v.Severity == VulnerabilitySeverity.Critical);
            HighCount = allVulnerabilities.Count(v => v.Severity == VulnerabilitySeverity.High);
            MediumCount = allVulnerabilities.Count(v => v.Severity == VulnerabilitySeverity.Medium);
            LowCount = allVulnerabilities.Count(v => v.Severity == VulnerabilitySeverity.Low);

            // Apply initial filtering
            FilterVulnerabilities();

            _logger.LogInformation("Loaded {Count} vulnerabilities", TotalVulnerabilities);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to load vulnerabilities");
        }
        finally
        {
            IsLoading = false;
        }
    }

    private async Task RefreshVulnerabilities()
    {
        await LoadVulnerabilities();
    }

    private void ViewDetails(Vulnerability vulnerability)
    {
        SelectedVulnerability = vulnerability;
        _logger.LogInformation("Viewing details for vulnerability {Id}", vulnerability.Id);
    }

    private async Task ExportVulnerability(Vulnerability vulnerability)
    {
        try
        {
            _logger.LogInformation("Exporting vulnerability {Id}", vulnerability.Id);
            
            // In a real implementation, this would generate a detailed report
            // for the specific vulnerability
            await Task.CompletedTask;
            
            _logger.LogInformation("Vulnerability exported successfully");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to export vulnerability");
        }
    }

    private void FilterVulnerabilities()
    {
        FilteredVulnerabilities.Clear();
        
        var vulnerabilities = Vulnerabilities.AsEnumerable();

        // Apply search filter
        if (!string.IsNullOrWhiteSpace(SearchText))
        {
            vulnerabilities = vulnerabilities.Where(v => 
                v.Title.Contains(SearchText, StringComparison.OrdinalIgnoreCase) ||
                v.Description.Contains(SearchText, StringComparison.OrdinalIgnoreCase) ||
                v.AffectedEndpoint.Contains(SearchText, StringComparison.OrdinalIgnoreCase) ||
                v.Type.Contains(SearchText, StringComparison.OrdinalIgnoreCase));
        }

        // Apply severity filter
        if (SelectedSeverityFilter.HasValue)
        {
            vulnerabilities = vulnerabilities.Where(v => v.Severity == SelectedSeverityFilter.Value);
        }

        // Apply type filter
        if (!string.IsNullOrWhiteSpace(SelectedTypeFilter) && SelectedTypeFilter != "All")
        {
            vulnerabilities = vulnerabilities.Where(v => v.Type == SelectedTypeFilter);
        }

        // Add filtered vulnerabilities
        foreach (var vulnerability in vulnerabilities)
        {
            FilteredVulnerabilities.Add(vulnerability);
        }
    }

    public string GetSeverityDisplayName(VulnerabilitySeverity severity)
    {
        return severity switch
        {
            VulnerabilitySeverity.Critical => "Critical",
            VulnerabilitySeverity.High => "High",
            VulnerabilitySeverity.Medium => "Medium",
            VulnerabilitySeverity.Low => "Low",
            VulnerabilitySeverity.Informational => "Informational",
            _ => severity.ToString()
        };
    }

    public string GetSeverityColor(VulnerabilitySeverity severity)
    {
        return severity switch
        {
            VulnerabilitySeverity.Critical => "CriticalBrush",
            VulnerabilitySeverity.High => "HighBrush",
            VulnerabilitySeverity.Medium => "MediumBrush",
            VulnerabilitySeverity.Low => "LowBrush",
            VulnerabilitySeverity.Informational => "InfoSecondaryBrush",
            _ => "TextSecondaryBrush"
        };
    }

    public string GetConfidenceText(double confidence)
    {
        return confidence switch
        {
            >= 0.9 => "Very High",
            >= 0.7 => "High",
            >= 0.5 => "Medium",
            >= 0.3 => "Low",
            _ => "Very Low"
        };
    }

    public string GetConfidenceColor(double confidence)
    {
        return confidence switch
        {
            >= 0.7 => "SuccessBrush",
            >= 0.5 => "WarningBrush",
            _ => "ErrorBrush"
        };
    }

    public string FormatTimestamp(DateTime timestamp)
    {
        var timeSpan = DateTime.UtcNow - timestamp;
        
        return timeSpan.TotalDays switch
        {
            >= 1 => $"{(int)timeSpan.TotalDays} days ago",
            >= 1.0/24 => $"{(int)timeSpan.TotalHours} hours ago",
            >= 1.0/(24*60) => $"{(int)timeSpan.TotalMinutes} minutes ago",
            _ => "Just now"
        };
    }
}